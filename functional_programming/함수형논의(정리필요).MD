리액티브 프로그래밍은 시간에 상관없이 stream
rx는 array를 전달할때, array를 전달하는게 아니고 항상 observerable을 받고 observable을 넘긴다.

함수형
이터레이션을 가정하고 메소드를 만드는 이유는? 쌍이 계속해서 연결되면 array이다. 함수형은 계속해서 일관된 데이터를 보내서 그것을. 마지막에는 이터레이션을 reduce를 사용하던 뭘사용하던해서 결과를 만들어낸다.
정제과정일때는(map, reduce로 이어지면 하나의 함수이다)
리스트프로세싱을 선호하는거지, 함수를 이어붙이는것도 함수합성이고, 함수형이다.
iferretive(절차지향적)은 for문을 사용해 과정하나하나를 설명하는것이고, decrative(선언지향적)는 map에다가 람다(무기명함수)를 넣어서 우리가 그게 뭔지를 안다. 함수형이 절차지향적이라 하지만 map과 같은것은 선언적이다. 뭐라고 이야기할 수 없다. 사실 선언지향적이다.
pipe는 조각을 
모든 함수는 monade를 받고 넘길 수 있도록 제작을 해야한다. 연산이 끊기지않고 컨트롤 할 수 있는 함수를 만들 수 있게되면, 더큰범위를 계속해서 합성해서 더 큰 합성 조합을 만들 수 있다.
마플에서 객체지향이라는걸 설계할때 빼놓을 수 없다. 함수형이라는게 100% 함수형이여야 하는것이 아니다. 예를 들어서 class를 만든다고해도 안에것이 전부다 함수형이면 된다. 컴포넌트 설계는 객체지향인데 속에서 움직이는 것은 함수형이다.

람다대수
모나드의 개념 정확하게 이해하기
https://stackoverflow.com/questions/51542865/is-rxjs-observable-a-monad

불변성이 중요한 이유는 무엇인가?

예측가능성
side effect를 불러일으키지 않음
변화를 추적하기 좋다.(예를 들어 깃도 히스토리를 적는것처럼)
기존의 있던 내용들이 그대로 있고, 새로운 것을 만든다(불변객체)

단점은 성능상의 문제(커다란 객체를 계속해서 찍는다면,,?) -> 해결책 structure sharing, 트리, 변환되지 않는 녀석은 트리로 참조 아닌녀석은 새로 만들기

partial application
의존성주입에서 이야기가 나온다
하스켈 커리가 람다대수를 정립하고, 람다대수는 함수가 매개변수가 한개일때 여러개를 이어붙여서 열을 만든것. 매개변수가 여러개

부분적용은 매개변수를 미리 넣어 놓는것, 즉 의존성 주입 생성자에 의존성 주입할때 쓰는것, 즉 함수 생성자!!!

만약 객체지향이였음면 this를 사용했겠지?
클로저가 자바스크립트에 존재하기때문에 부분적용이 된다!!

자바스크립트에서는 별로다
구현할수도있지만 타입스크립트 컴파일시간이 느려진다. 함수를 실행하는 오버헤드가 커진다. 자바스크립트가 받아들이기에 옳지않다. 선진적인 함수형언어에서는 커링을 다해주는데 한땀한땀해줘야한다면 성능, 코딩에도 오버헤드이다.

매개변수의 순서x (커링)
부분적용을 쓰는게 좋다

똑똑한 함수형 코딩

immutablejs 보다 방어적복사
immutablejs가 복잡한 구조를 다룰때는 좋지만, 내장객체나 배열을 사용하는게 좋다 아니면 "immer"
어떠한 언어의 표준에서 벗어나면 사용하기가 어렵기떄문에, 내장객체를 불변하게 사용하느게 좋지않을까
간단한건 스프레드연산자, 복잡한건 immer
사실 타입스크립트를 쓸떄, readonly 또는 as const를 사용하면 된다
업계표준에서 벗어나는것은 별로이다@!!!!!!
변경하는 adapter를 다 짜야한다.

업계표준은 또 promise이다.
async awiat은 함수형인가? 스칼라의 for문이랑 하스켈의 donation이랑 같은것이다. 결국 promise가 monad이다.
observable을 꼭 써야하는게 아니면 promise를 쓰는게 코드의 복잡도도 줄이고, 속도가 빠르다.

funcotr => map
monad => unit, appy, flatMap 가 구현되어 있는것.

[1,2,3,4].map( n => n*n)

(n => n*n)(4)

교환법칙,결합법칙 등 3개의 법칙이 된다는걸 증명
모나드는 수학적으로 증명을 한것이다.
비동기에 한정해서 가져온것이 async await, 수학적으로 된다고 증명이되어있다.
promise는 계획이다.
await은 완성되었을때 꺼내고 아니면 기다리다.
async함수로 감싸야지만 계획이라는것을 알 수 있따.

flatmap은 중첩을 막기위함이다.
promise의 map은 then

그런데 then은 map이면서 flatmap이다.

monoid는 어떤 값들의 이항연산이 정의되인것(number 또는 promise는 +에 monoid이다.
프로미스는 모나드가 아니라는 사람도 있지만, 대부분의 증명은 되어있따.
then, async는 자동으로 flat을 해준다.

일반적인 함수형인 언어라면 모두 모나리(단항함수)를 따른다.
하지만 자바스크립트는 다인자 함수가 기본이다.

curry는 단항함수들을 이어 붙인다.
partial application은 다항함수로 사용할 수 있다.

자바스크립트에서 단항함수로 모든것을 만든다면 curry를 사용할 수 있지만, 그게 

상용서버에다가 실제 e2e테스트를 하지마라, 다른개발자에들에게 민폐다. 로그분석, 코드부하 증가 등 다른 부서에서도 공유하고 있는 외부서비스에 요청을 보내는ㄴ것은 좋지않다. 항상 내 로컬에서 해라

e2e test는 시나리오대로(결국 회사 외부의존성과 실제로 할 수 밖에없음)
integration은 외부의존성(하나씩만해야하는 이유는 어떤것에서 발생했는지 알기위해서)

ramda 판타지에서 either, future행은 monad등의 열은 충족해야한다.

uow에서는 ok or not만 판별해서 같은형태의 데이터를 전달해준다(nodejs의 첫째인자를 nuill 또는 error객체로 주는것처럼)

log객체와 data를 모나드(promise)로 전달할 수 있을까

순수함수가 아닌것에 커리를 하는것이 의미가 있나

하스켈의 io모나드는 액션인데,,, 모나드다...?
그럼액션도 함수형으로 작성할수있따는건데, 그럼 모나드에는 액션을 담을수있고, 순수함수로 작성할수있다는거다. 근데 왜 액션을 굳이 나눠서, 액션이들어가면 함수형이 되지 않는가

액션의존적인것도 함수형으로 작성가능한가?'
함수형이 될수 있다면 모나드가 추상화해줘서 순수함수로 할수 있다는건지, 함수형이라는것의 의미가 순수함수에 국한되지 않는건지.
그렇다면 대체 함수형은 무엇인지? 불변성과 순수함수라는것으로 설명되어있는데, 왜하스켈은 액션조차 함수형으로짤수있고, 근데 순수함수여야하고, 근데 순수는함수는 사이드이펙트를 포함하면안되고, 그러면 io모나드는 왜있고?

함수형이라는게 순수함수여야하는가? 모나드는 액션을 포함할 수 있는가? 그렇다면 우리의 플로우의 service, repsitory 즉 action도 함수형으로 표현이 가능한건지, 그렇다면 어떻게 구성해야할지?
방금말한게 맞다면 도메인만이 함수형으로 짜여지는건지?



1. 도메인함수는 어떤곳에서든 임포트할수있지만 서비스가 임포트하는게 좋다(그로킹에서는 컨트롤러에서 한다. 객체지향에서 나온 ddd에서 함수형을 사용하려면(사용하기 좋다), 
2. uow는 동시성상황에서 무결성을 보장한다.(actor 모델), 도메인함수의 로직을 db쿼리로 바꿔주는게 repository, orm이다. 직접 orm의 save를 하는게 아니라, 배열전체를 쿼리를 save를 하는거다. 로직을 repository는 알아선안된다. 순수한건 도메인이고, uow는 순수하지 못한것을 구현한다.
3. db가 순수하지 못하다는거는 실제 db를 사용하지 않는다면 순수하게 짤 수 있다. 직접 통제한다면 순수해질 수 있다. 순서에대한것을 배제하고 이야기하면(결과값이 나오기전에 undefined 에러가 안뜨면 순수한것이다.) 쓰기만 하지만 덮어쓰지만 않으면 순수한것이다. 기존의 상태값을 덮어쓰는것은 순수하지 않다. save를 하는것은 덮어쓰는건 순수하지않다. unitofwork는 항상 일관되고, 결과가 결정적으로 나오면 순수하다. test를 해보면 순수하다, 항상 똑같은 결과가 나오면 순수하다. uow가 순수하다는건 get하고 save하고 commit을 하는데, commit하기 전까지 쭉쭉쌓아오는것은 부수효과에 영향을 미치는것이 아니고, 다끝나서 커밋이 되면 순수하지않다. 왜 순수해야하나? 세상의 모든것은 순수하지 않다. 순수한건 테스트하기 쉽기때문에 사용하는것이다. 트랜잭션은 계획이다. 커밋하는 순간에 부수효과를 일으킨다. 순수함에 대해서 따지기에는, 이렇게 순수하게 만들면 테스트하기 펺해지나? 실수가 줄어드나? 중요한건 순수한것이가가 아니라 테스트하기 좋나? 순수한가?로 생각해야한다. 방어적복사를 해놔라. db에서 데이터를 가져오는것은 복사하는것이다. 복사해놓은것을 수정하는것은 복사본을 수정하는것이다. 바깥에서 보기에는 부수효과가 없지만, uow안에서는 순수하지 않다. uow안에서 이전상태를 주면 다른 상태를 주게 만들면 테스트하기 편하다. 자바스크립트의 map은 for로 이루어져 있어서, 순수하지않다. 인터페이스가 순수해보이면 그거는 순수함수다. 보이지않는 부수효과는 순수하다!!!!!! (클로저를 만든 사람도 그렇게 이야기함) (바깥에 있는 어떤것도 건들지 않으면 순수한것이다!!) (동시성 상황에서 일관성을, 전역변수가 모든것을 건드리면 어려운건데, 이 상태를 계산했더니 다음 결과가 나오는데 그것을 보장하는것)(맨처음 상태, 두번쨰상태, 세번째 상태!!!)(트랜잭션으로 계산을 하고 있는동안 전제가 바뀌지않음을 보장하고, 그 동안 데이터를 락한다는것!)(레디스는 한번에 하나만 처리하기 때문에 동시성 문제가 없다. 인메모리라 매우빨라서 스레드를 여러개 사용할 필요가없다.)
4. commit을 할때 save가 되어야한다!!!!! lazy하게 todo에 새로운 todo가 추가된 배열을 만든다. 원본상태를 db에서 가지고 오고, 그걸 새롭게 배열을 생성하면 된다.
5. 얼마나 어디까지 순수한가! 바깥에서 보기에 전체적인건 순수하다. save를 하는 순간은 순수하지 않다. 외부에 영향을 미치지 않는다. 외부에 부수효과가 있어서는 안된다. 외부에 부수효과를 일으키면 teardown해야하는게 아니라면
6. map,set은 가변적으로 쓰게됨 자바스크립트에서는, 불변을 쓰려면 성능상 불이익, 순수하게 보이기만 하면된다.
7. update를 하면안되고, db의 의존성이 생긴다. db에서 그런로직을 처리하지않으려면 서버에서 처리해야한다. pop하는게 delete이고 insert 하는게 save이다. 기존과 달라진것을 비교해서 즉 repository는 서비스가 조작한 결과를 해석하도록 해야한다. (aggregate 개념)
8. update하고 delete하는것은 domain에서 처리되어야한다. 신기능을 만들면 순수함수하나만 만들면된다. repository는 단지 서비스에서 전달해주는것을 해석하는 역할만한다. 언제 삭제되는지, 왜 삭제되는지는 서비스, 도메인에서 전달해 주는것이다.
9. 서비스가 re한테 데이터를 가져오게하고, 도메인한테 계산하게 하고 re한테 넘긴다.(사진1)
10. 여러가지의 table을 처리하는 것이 aggregate이다. 객체를 하나하나 저장한다는 사고방식에서 벗어나야한다. aggregate(집계한다) . typeorm이 aggregate를 전부 확인해보고, 바꾼것들 알아서 날려준다. 1대1매핑에서 벗어나야한다. 다양한 객체(aggregarte)를 만들어놓고, 그 aggregate를 업데이트하는것이다. 스토어라는 ㅁggreage가 있으면 판매자, 품목이다. 같은 테이블이라도 다른 ㅁggregate로 처리한다. 테이블을 하나하나 생각하는것에서 벗어나서, js에서 사용하는 객체를 디비에 반영하는것. 디비에서 하는것을 생각하지 않고, 객체를 전달해주면 typeorm이 처리하게 되는것이다. 쿼리빌더(쿼리를 직접짜는것)는 읽기연산을 사용하고(복잡하기 때문에), 일관성을 지켜야하는 insert, delete, update 커맨드(mutation)는 typeorm이 알아서 처리하도록 해야한다.
11. dsl을 해석기를 이용해 해석하는게 ttypeorm이다.(실제 쿼리도 깃허브에 있다.)
12. 굳이 모나드를 사용하지 않아도 함수형이다. 클로저는 안쓰고 하스켈은 쓴다. 계획을 표현하는 수단이다. 트랜잭션은 모드에 가깝다. 부수효과가 있는 연산을 감싸놓았다고 모나드가 되는게 아니고, 합칠 수 있어야 모나드이다. 트랜잭션을 합칠 수 있다면, 모나드라고 할 수 있따. 프로미스와 프로미스르 합칠 수 있다면 모나드이다.
13. 모나드는 합쳐지거나 컨텍스트가 중첩되는 경우에 필요하다. 두겹이되는걸 하나로 합쳐주는걸 모나드라고한다. optional chaining이 flatmapflatmap하는것 모나드 하위호환.
14. java orm jpa표준 프로그래밍(객체지향스럽게 오브젝트를 알아서 반영이 된다라는걸 설명해준책, 파이썬 아키텍쳐를 참고해라)
15. 실용성, 순수 setup, teardown하기 어렵다. 라는것에 집중하자. 테스트, 부수효과, 의존성을 줄이는거에 집중하자. 순수주의자가 아니다.
16. 자바스크립트에서 모나드를 사용하는게 어렵다. 찐 함수형을 하려면 세계관이 바뀌어야하기때문에 모나드로 가려고 하지말고, 잘 이해하지 못하는 개념을 사용하기 보다, 의존성, 부수효과를 끊을까에 집중해서 보고, 함수형, 객체지향에서 그개념을 차용해오려고해라

select는 부수효과가 있는것인가 아닌가(시점의 영향을 받는것이 아닌가)
겉에서 보이지 않는 부수효과가 무엇인지.

엘릭서
스위프트
스칼라
코틀린
러스트

동시성과 고가용성
영속성을 인메모리디비나 이벤트소싱(스냅샷으로 필요한 정보를 띄우기)으로!!(실시간 시스템, 하나의 게임동안은 전체가 저장이이되어야함)

리덕스로 이벤트소싱(액션 히스토리)으로 json을 주고 받으면 된다!

구조를 잘 짜놓으면 최적화하기가 쉽다. 최적화를 모두 생각해서 구조를짜고 코드를 쓰기보다, 최적화하기 편하도록 의존성을 줄이고, 테스트 환경을 잘구축해놓고, 실제로 측정해서 최적화가 필요할때 적용하는것이 옳다.

sideEffect는 pure function의 질을 떨어트린다.
sideEffect는 절대적인 개념이 아닌, 상대적인 개념이다. 서비스의 sideEffect를 바라보는 수준에 따라 sideEffect의 정의가 달라진다.
sideEffect의 격리 수준에 따라 pure function의 정의가 달라진다.
sideEffect의 격리 수준에 따라 monadic하게 function을 만들수 있다.
추상화 수준이 높아질 수록 purefunction이지만, 모든 sideEffect를 100% 추상화 해버린다면, 그것은 서비스가 아니며, 수학이다.
서비스를 위해서는 적절한 추상화 정도가 필요하며, 그때 서비스라고 부를 수 있다.(86% 정도가 적절하다고한다.)

순수함수는 cachable하다. 비순수함수는 인자를 넣어도, 값이 매번 달라진다.

수학적인 함수는 정의역과 공역의 mapping이다. 하나의 정의역에서 여러개의 공역을 만들수 있다면 그건 function(pure function)이 아니다.

비순수함은 평가를 미룸으로써 순수 함수가 될 수 있다. monadic한 함수 또는 평가가 되지않은 monad를 연산의 마지막까지 인자로 전달하고, 마지막에 평가한다면, 이것은 비순수함수인것을 순수함수에 가깝게 구현할 수 있다.


1. 암묵적인 의존성을 모두 인자로 넘겨서, 인자에만 의존하게한다.
2. 비순수함수의 평가를 지연시킨다. 함수라는 값 자체로 바라보게만든다.
3. 사이드이펙트를 추상화한다. (평가되지 않는다로 생각해야하는가? 단적인 예는 either, monadic하게 만든다.)

프로그래밍은 수학이 아니라 과학이다. 완벽할 수 없다. 100% 완벽할 수 없기때문에, 99%가 된다면 그것을 확신하고, 사용해야한다.
100%완벽한것은 불가능하다. 불가능한것을 가능하게 하려면, 완벽이란 답의 의미를 어떻게 바라보는지 시각을 바꿔야한다.

monad에서 composition한 함수들은 map을 통해서, 새로운 함수를 생산한다. monad는 중간에 평가는 되지만, folding되어서 값이 전달된다. 마지막 map으로 실행된 함수는 최종 composition된 함수를 실행시키며, folding된 모나드를 열어서 사용한다.

함수형은 병렬처리에 사용하기에 좋다. 함수형의 함수들은 독립적으로 실행되기 때문에, 다른 함수에 전혀 영향을 끼치지않는다. 때문에 공통된 자원을 사용하는 병렬처리에서 사용하기에 좋다.




